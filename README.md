# smart-distributed-vulnerability-management
** **

## 1. Vision and Goals Of The Project:

Container build patterns are increasingly becoming layered and for different layers of applications, in retrospect, supply chains used to be evident and explicit, which means that respective software vendors were liable to ensure and maintain security of their own software. In such a pattern, we are obviously even its maintainers and supply chain and we are likely to do vulnerability remediations like “fix where discovered”, which is not inefficient.

In this project, we will design a new distributed system that would allow us to bind build workflows across all our dependencies through a common eventing framework, on which we can orchestrate smart, optimal remediation workflows.


## 2. Users/Personas Of The Project:

As for the users of the project, we have SBOM and Build operators, maintainers and coordinators of different dependency repos/pipelines.

SBOM operators will help to provide complete, accurate and auditable record of every dependency, Build operators will build the images based on its dependencies and a dependency graph is generated during this process and stored in the graph database for the remediation. And for the coordinator and maintainer of pipelines, When vulnerability happens, they will know where to fix based on dependency graph and also when there’s new update of  the exact information of the new update for a image of dependency,


** **

## 3.   Scope and Features Of The Project:

The first step in securing secure supply chain or SSC is the ability to provide complete, accurate and audit-able record of every dependency baked into building a deliverable software product or as generally referred to as Software Bill-of-Material (SBOM)

Software Bill-of-Material is in-scope

In engram we propose a new model, called sbom-ctl or sbom control plane, which is primarily an open, extensible platform for managing all sbom operations.

In engram, we propose replacing existing imperative build patterns with declarative patterns, wherein, instead of defining a recipe, developer can just define a desired build state for their applications. Multiple build operators then can then be implemented to achieve and maintain the desired state in a control loop. The operators should also functionally support observability and integrity.

Security pipelines is in-scope

Gauge

Declarative build

<!--- The Scope places a boundary around the solution by detailing the range of features and functions of the project. This section helps to clarify the solution scope and can explicitly state what will not be delivered as well.

It should be specific enough that you can determine that e.g. feature A is in-scope, while feature B is out-of-scope.-->

** **

## 4. Solution Concept

Global Architectural Structure Of the Project:

<!--Diagram-->

Design Implications and Discussion:

As shown in the diagram, in this project, we are going to build:

Dependency map: Dependencies need to be explicitly captured at different granularity  in order to find the source of vulnerabilities.
Eventing framework: The system should be aware of the updates of any dependencies in the chain. To accomplish it, an eventing framework would generate a cloudevent for each action with the changes and related information.

With these components, we are able to define an automated workflow. In the case of CI, we can get the new or updated dependencies through the eventing framework. CI build would be triggered If any event is using these dependencies.

## 5. Acceptance criteria

This section discusses the minimum acceptance criteria at the end of the project and stretch goals.

## 6.  Release Planning:

Release planning section describes how the project will deliver incremental sets of features and functions in a series of releases to completion. Identification of user stories associated with iterations that will ease/guide sprint planning sessions is encouraged. Higher level details for the first iteration is expected.

** **

## General comments

Remember that you can always add features at the end of the semester, but you can't go back in time and gain back time you spent on features that you couldn't complete.

** **

For more help on markdown, see
https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet



