package communication

import (
	"fmt"
	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/parser"
	"github.com/everfix/pkg/remediation"
	"log"
	"net/rpc"
	"sync"
	"time"
)

func Connect(serverInfo string) (*rpc.Client, error) {
	client, err := rpc.DialHTTP("tcp", serverInfo)
	if err != nil {
		fmt.Println("Dial HTTP ERROR")
		log.Fatal("Client created error", serverInfo)
		return nil, err
	}
	return client, nil
}

func FixAllImages(conf config.Config, vul *parser.Vulnerability) error {
	// send RPC to the image that need to fix concurrently
	// wait until all the server(s) gives successful reply
	var wg sync.WaitGroup
	images := vul.RemediationSteps[0].Images
	fixImagesSize := len(images)
	wg.Add(fixImagesSize)
	for i := 0; i < fixImagesSize; i++ {
		imageName := images[i]
		go func() {
			defer wg.Done()
			done, err := SendRPC(conf, config.FIX, vul, imageName)
			if err != nil {
				return
			}
			if done == false {
				log.Fatal("Fix image failed", imageName)
			}
		}()
	}
	wg.Wait()
	return nil
}

// todo: implement RebuildImage
func RebuildAllImages(conf config.Config, vul *parser.Vulnerability, children map[string][]string) error {
	imagesToRebuild := remediation.GetImagesToRebuild(vul.FixStatus, children)
	for len(imagesToRebuild) != 0 {
		var wg sync.WaitGroup
		wg.Add(len(imagesToRebuild))
		for i := 0; i < len(imagesToRebuild); i++ {
			imageName := imagesToRebuild[i]
			go func() {
				defer wg.Done()
				done, err := SendRPC(conf, config.REBUILD, vul, imageName)
				if err != nil {
					return
				}
				if done == false {
					log.Fatal("Rebuild image failed", imageName)
				}
			}()
		}
		wg.Wait()
		imagesToRebuild = remediation.GetImagesToRebuild(vul.FixStatus, children)
	}
	return nil
}

func SendRPC(conf config.Config, action config.StepOP, vul *parser.Vulnerability, image string) (bool, error) {
	imageIp := conf.AddressConfig[image]
	client, err := Connect(imageIp)
	defer client.Close()
	c := make(chan error, 1)
	retryTimes := 0
	if err != nil {
		return false, err
	}
	for {
		var req RequestMessage
		if action == config.FIX {
			req = RequestMessage{
				Action:            action,
				VulnerabilityName: vul.Name,
				ImageName:         image,
				BaseImageVersion:  make(map[string]string),
			}
		} else if action == config.REBUILD {
			req = RequestMessage{
				Action:            action,
				VulnerabilityName: vul.Name,
				ImageName:         image,
				BaseImageVersion:  vul.FixStatus.GetMap(),
			}
		}

		rsp := ResponseMessage{}
		go func() {
			c <- client.Call("Fix", req, &rsp)
		}()
		select {
		case err := <-c:
			if err != nil {
				return false, err
			}
			if rsp.Success == true {
				vul.FixStatus.Set(image, rsp.FixedVersion)
				return true, nil
			} else {
				retryTimes++
				if retryTimes >= conf.RPCConfig.RetryTimes {
					return false, nil
				}
			}
		case <-time.After(time.Duration(conf.RPCConfig.Timeout)):
			retryTimes++
			if retryTimes >= conf.RPCConfig.RetryTimes {
				return false, nil
			}
		}
	}
}
