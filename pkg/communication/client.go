package communication

import (
	"fmt"
	"github.com/everfix/pkg/config"
	"log"
	"net/rpc"
	"sync"
	"time"
)

type RequestMessage struct {
	Action            config.StepOP // can be "fix" or "rebuild"
	VulnerabilityName string
	ImageName         string
}

type ResponseMessage struct {
	Success           bool
	VulnerabilityName string
	ImageName         string
}

func Connect(serverInfo string) (*rpc.Client, error) {
	client, err := rpc.DialHTTP("tcp", serverInfo)
	if err != nil {
		fmt.Println("Dial HTTP ERROR")
		log.Fatal("Client created error", serverInfo)
		return nil, err
	}
	return client, nil
}

// todo: implement FixImage
func FixAllImages(conf config.Config, vulName string, images []string, fixStatus *config.RWMap) error {
	// send RPC to the image that need to fix concurrently
	// wait until all the server(s) gives successful reply
	var wg sync.WaitGroup
	fixImagesSize := len(images)
	wg.Add(fixImagesSize)
	for i := 0; i < fixImagesSize; i++ {
		imageName := images[i]
		go func() {
			defer wg.Done()
			done, err := SendRPC(conf, config.FIX, vulName, imageName, fixStatus)
			if err != nil {
				return
			}
			if done == false {
				log.Fatal("Fix image failed", imageName)
			}
		}()
	}
	wg.Wait()
	return nil
}

// todo: implement RebuildImage
func RebuildImages(conf config.Config, image string, rebuildStatus *config.RWMap) error {
	return nil
}

func SendRPC(conf config.Config, action config.StepOP, vulName string, image string, fixStatus *config.RWMap) (bool, error) {
	imageIp := conf.AddressConfig[image]
	client, err := Connect(imageIp)
	c := make(chan error, 1)
	retryTimes := 0
	if err != nil {
		return false, err
	}
	for {
		req := RequestMessage{
			Action:            action,
			VulnerabilityName: vulName,
			ImageName:         image,
		}
		rsp := ResponseMessage{}
		go func() {
			c <- client.Call("Server.Rebuild", req, &rsp)
		}()
		select {
		case err := <-c:
			if err != nil {
				return false, err
			}
			if rsp.Success == true {
				fixStatus.Set(image, true)
				return true, nil
			}
		case <-time.After(time.Duration(conf.RPCConfig.Timeout)):
			retryTimes++
			if retryTimes >= conf.RPCConfig.RetryTimes {
				return false, nil
			}
		}
	}
}
