package remediation

import (
	"github.com/everfix/pkg/config"
)

type ImageTreeNode struct {
	ImageName     string
	ChildrenNodes []*ImageTreeNode
}

type Step struct {
	Op     config.StepOP
	Images []string
}

type Remediation []Step

// GetRemediationWorkflow Get the Remediation steps for fixing the vulnerability
// todo: new algorithm for remediation
func GetRemediationWorkflow(relatedImages []string, imageTreeNode *ImageTreeNode) (Remediation, error) {
	fixStep := Step{
		Op:     config.FIX,
		Images: []string{},
	}
	rebuildStep := Step{
		Op:     config.REBUILD,
		Images: []string{},
	}
	remediationSteps := Remediation{fixStep, rebuildStep}
	fixedImages := new([]string)
	DFS(imageTreeNode, relatedImages, fixedImages, remediationSteps)
	return remediationSteps, nil
}

func DFS(currentImageNode *ImageTreeNode, relatedImages []string, fixedImages *[]string, remediationSteps Remediation) {
	currentImageName := currentImageNode.ImageName
	// if current image node is leaf node, then fix this node
	if currentImageNode.ChildrenNodes[0].ImageName == "" {
		if config.Contains(relatedImages, currentImageName) {
			remediationSteps[0].Images = append(remediationSteps[0].Images, currentImageName)
			*fixedImages = append(*fixedImages, currentImageName)
		}
		return
	}
	// current node is not leaf node, get the index of base image that need to fix
	unfixedIndex := GetAllUnfixedBaseImage(currentImageNode, relatedImages, *fixedImages)
	// dfs to next level
	for _, imageIndex := range unfixedIndex {
		DFS(currentImageNode.ChildrenNodes[imageIndex], relatedImages, fixedImages, remediationSteps)
	}
	// if all the base images have been fixed, then rebuild current image
	if AllBaseImagesFixed(currentImageNode, relatedImages, *fixedImages) {
		if config.Contains(relatedImages, currentImageName) {
			if baseImagesNotRelated(currentImageNode, relatedImages) {
				remediationSteps[0].Images = append(remediationSteps[0].Images, currentImageName)

				*fixedImages = append(*fixedImages, currentImageName)
			} else {
				remediationSteps[1].Images = append(remediationSteps[1].Images, currentImageName)
				*fixedImages = append(*fixedImages, currentImageName)
			}
		}
		return
	}

}

func baseImagesNotRelated(currentImageNode *ImageTreeNode, relatedImages []string) bool {
	children := currentImageNode.ChildrenNodes
	for _, child := range children {
		if config.Contains(relatedImages, child.ImageName) {
			return false
		}
	}
	return true
}

func GetAllUnfixedBaseImage(currentImageNode *ImageTreeNode, relatedImages []string, fixedImages []string) []int {
	baseImages := currentImageNode.ChildrenNodes
	var unfixedImages []int
	for i, image := range baseImages {
		if config.Contains(relatedImages, image.ImageName) {
			if !config.Contains(fixedImages, image.ImageName) {
				unfixedImages = append(unfixedImages, i)
			}
		}
	}
	return unfixedImages
}

func AllBaseImagesFixed(currentImageNode *ImageTreeNode, relatedImages []string, fixedImages []string) bool {
	baseImages := currentImageNode.ChildrenNodes
	for _, image := range baseImages {
		if config.Contains(relatedImages, image.ImageName) {
			if !config.Contains(fixedImages, image.ImageName) {
				return false
			}
		}
	}
	return true
}
