package config

import (
	"bufio"
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"sync"
)

type StepOP string

const (
	// For DB connection
	Uri      = "neo4j://localhost:7687"
	Username = "neo4j"
	Pwd      = "test"
	Realm    = ""

	// For vulnerability
	WONT_FIX   = "won't fix"
	NEGLIGIBLE = "Negligible"
	LOW        = "Low"
	MEDIUM     = "Medium"
	HIGH       = "High"
	CRITICAL   = "Critical"

	// File directories
	SBOM_DIR       = "bom"
	DOCKERFILE_DIR = "dockerfile"

	// Remediation workflow type / action
	FIX     StepOP = "fix"
	REBUILD StepOP = "rebuild"

	// File types
	SPDX_JSON = "spdx-json"
	JSON      = "json"
	TEXT      = "text"
	GITHUB    = "github"
	TABLE     = "table"
)

type ImageConfig struct {
	ImageName   string
	ImageSource string
}

type RPCConfig struct {
	Timeout    int
	RetryTimes int
	//ImagesUri  map[string]string
}

type Config struct {
	// image info
	ImageConfig ImageConfig
	// rpc info
	RPCConfig RPCConfig
	// address info
	AddressConfig map[string]string
}

// Helper functions

func Contains(items []string, item string) bool {
	for _, eachItem := range items {
		if eachItem == item {
			return true
		}
	}
	return false
}

func InitConfig(conf *Config) error {
	content, err := ioutil.ReadFile("config/config.json")
	if err != nil {
		log.Fatal("Error opening config file")
		return err
	}
	err = json.Unmarshal(content, &conf)
	if err != nil {
		log.Fatal("Error loading config data")
		return err
	}
	addressConfig := make(map[string]string)
	conf.AddressConfig = addressConfig
	err = InitAddressInfo(conf)
	return nil
}

func InitAddressInfo(conf *Config) error {
	readFile, err := os.Open("config/images_address")
	defer readFile.Close()
	if err != nil {
		log.Fatal("Error opening address config file")
		return err
	}
	fileScanner := bufio.NewScanner(readFile)
	fileScanner.Split(bufio.ScanLines)
	for fileScanner.Scan() {
		line := fileScanner.Text()
		image := strings.Split(line, " ")[0]
		address := strings.Split(line, " ")[1]
		conf.AddressConfig[image] = address
	}
	return nil
}

type RWMap struct {
	sync.RWMutex
	m map[string]string
}

func NewRWMap() *RWMap {
	return &RWMap{
		m: make(map[string]string),
	}
}

func (m *RWMap) Get(key string) (string, bool) {
	m.RLock()
	defer m.RUnlock()
	v, existed := m.m[key]
	return v, existed
}

func (m *RWMap) GetMap() map[string]string {
	m.RLock()
	defer m.RUnlock()
	return m.m
}

func (m *RWMap) Set(key string, value string) {
	m.Lock()
	defer m.Unlock()
	m.m[key] = value
}

func (m *RWMap) Delete(key string) {
	m.Lock()
	defer m.Unlock()
	delete(m.m, key)
}

func (m *RWMap) GetEmptyValueKey() string {
	m.RLock()
	defer m.RUnlock()
	for k, v := range m.m {
		if v == "" {
			return k
		}
	}
	return ""
}

func (m *RWMap) Len() int {
	m.RLock()
	defer m.RUnlock()
	return len(m.m)
}

func (m *RWMap) Partition() ([]string, []string) {
	m.RLock()
	defer m.RUnlock()
	emptyGroup := make([]string, 0)
	modifiedGroup := make([]string, 0)
	for k, v := range m.m {
		if v == "" {
			emptyGroup = append(emptyGroup, k)
		} else {
			modifiedGroup = append(modifiedGroup, k)
		}
	}
	return emptyGroup, modifiedGroup
}
