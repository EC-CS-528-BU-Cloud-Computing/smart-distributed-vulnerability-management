package neo4j

import (
	"context"
	"fmt"
	"github.com/everfix/pkg/config"
	"time"

	"github.com/guacsec/guac/pkg/assembler"
	"github.com/guacsec/guac/pkg/handler/collector"
	"github.com/guacsec/guac/pkg/handler/collector/file"
	"github.com/guacsec/guac/pkg/handler/processor"
	"github.com/guacsec/guac/pkg/handler/processor/process"
	"github.com/guacsec/guac/pkg/ingestor/parser"
	"github.com/guacsec/guac/pkg/logging"
)

var ctx context.Context

// TODO: add error logger
// var logger logging.logger

func init() {
	ctx = logging.WithLogger(context.Background())
	// logger := logging.FromContext(ctx)

}

func Parse(path string) error {
	fileCollector := file.NewFileCollector(ctx, path, false, time.Second)
	err := collector.RegisterDocumentCollector(fileCollector, file.FileCollector)
	if err != nil {
		fmt.Printf("unable to register file collector: %v", err)
	}
	errHandler := func(err error) bool {
		if err == nil {
			fmt.Println("collector ended gracefully")
			return true
		}
		fmt.Printf("collector ended with error: %v\n", err)
		return false
	}
	collector.Collect(ctx, EmitterFunc, errHandler)
	return nil
}

func EmitterFunc(d *processor.Document) error {
	docTree, err := ProcessorFunc(d)
	if err != nil {
		return fmt.Errorf("unable to process doc: %v, fomat: %v, document: %v", err, d.Format, d.Type)
	}

	graphs, err := IngestorFunc(docTree)
	if err != nil {
		return fmt.Errorf("unable to ingest doc tree: %v", err)
	}

	err = AssemblerFunc(graphs)
	if err != nil {
		return fmt.Errorf("unable to assemble graphs: %v", err)
	}
	return nil
}

func ProcessorFunc(d *processor.Document) (processor.DocumentTree, error) {
	docTree, err := process.Process(ctx, d)
	if err != nil {
		fmt.Printf("Error processing file: %v\n", err)
		return nil, err
	}
	return docTree, nil
}

func IngestorFunc(docTree processor.DocumentTree) ([]assembler.Graph, error) {
	fmt.Println("Generating graph components...")
	inputs, err := parser.ParseDocumentTree(ctx, docTree)
	if err != nil {
		fmt.Printf("Error parsing document tree: %v\n", err)
		return nil, err
	}
	return inputs, nil
}

func AssemblerFunc(inputs []assembler.Graph) error {
	// generate graph in main
	client, err := CreateDriver(config.Uri, config.Username, config.Pwd, config.Realm)
	if err != nil {
		return err
	}
	fmt.Println("Assembling graph and store to main...")
	combined := assembler.Graph{
		Nodes: []assembler.GuacNode{},
		Edges: []assembler.GuacEdge{},
	}
	for _, g := range inputs {
		combined.AppendGraph(g)
	}

	if err != nil {
		return err
	}
	if err := assembler.StoreGraph(combined, client); err != nil {
		return err
	}
	return nil
}
