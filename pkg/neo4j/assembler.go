package neo4j

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/generator"
	"github.com/everfix/pkg/parser"
)

type ImageTreeNode struct {
	ImageName     string
	ChildrenNodes []ImageTreeNode
}

// AssembleGraph generate the image & package graph and generate a image tree that represents the base image relation
func AssembleGraph(image string, source string, dockerfile string, imageTreeNode *ImageTreeNode) {
	if image == "scratch:" {
		return
	}
	// generate generator for current image
	fmt.Println("Generating SBOM for image:", image)
	generator.GenerateSBOM(image, source, config.SPDX_JSON)
	baseImages, err := parser.GetBaseImages(filepath.Join(config.DOCKERFILE_DIR, dockerfile))
	if err != nil {
		fmt.Println("****Error when retrieving base image of ", image)
		return
	}
	fmt.Printf("Image %s contains %d bases\n", image, len(baseImages))
	imageName := filepath.Join(config.ImageSource, strings.Replace(image, ":", "-", -1))
	imageTreeNode.ImageName = imageName
	for _, base := range baseImages {
		subNode := new(ImageTreeNode)
		if base.Name == "scratch" {
			fmt.Printf("%s doees not have base image\n", image)
		}
		baseImage := base.Name + ":" + base.Tag
		AssembleGraph(baseImage, config.ImageSource, baseImage, subNode)
		imageTreeNode.ChildrenNodes = append(imageTreeNode.ChildrenNodes, *subNode)
		// parse generator and generate clusters
		fmt.Println("Parsing SBOM and building dependency tree for image: ", image)
		err = Parse(filepath.Join(config.SBOM_DIR, ""))
		if err != nil {
			fmt.Println("****Error when building graph for image: ", image)
			return
		}
		// add relationship from image to its base
		baseName := filepath.Join(config.ImageSource, base.Name) + "-" + base.Tag
		// generate relationship for image and its base
		fmt.Printf("Creating `Base Image` relationship from %s to %s\n", imageName, baseName)
		GenerateRelation(imageName, baseName)
	}

}
