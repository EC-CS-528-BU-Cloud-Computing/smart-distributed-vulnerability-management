package graph

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/neo4j"
	"github.com/everfix/pkg/parser"
	"github.com/everfix/pkg/sbom"
)

func AssembleGraph(image string, source string, dockerfile string) {
	if image == "scratch:" {
		return
	}
	// generate sbom for current image
	fmt.Println("Generating SBOM for image:", image)
	sbom.GenerateSBOM(image, source, sbom.SPDX_JSON)
	baseImages, err := parser.GetBaseImages(filepath.Join(config.DOCKERFILE_DIR, dockerfile))
	if err != nil {
		fmt.Println("****Error when retrieving base image of ", image)
		return
	}
	fmt.Printf("Image %s contains %d bases\n", image, len(baseImages))
	imageName := filepath.Join(config.ImageSource, strings.Replace(image, ":", "-", -1))
	for _, base := range baseImages {
		if base.Name == "scratch" {
			fmt.Printf("%s doees not have base image\n", image)
		}
		baseImage := base.Name + ":" + base.Tag
		AssembleGraph(baseImage, config.ImageSource, baseImage)
		// parse sbom and generate clusters
		fmt.Println("Parsing SBOM and building dependency tree for image: ", image)
		err = parser.Parse(filepath.Join(config.SBOM_DIR, ""))
		if err != nil {
			fmt.Println("****Error when building graph for image: ", image)
			return
		}
		// add relationship from image to its base
		baseName := filepath.Join(config.ImageSource, base.Name) + "-" + base.Tag
		// generate relationship for image and its base
		fmt.Printf("Creating `Base Image` relationship from %s to %s\n", imageName, baseName)
		neo4j.GenerateRelation(imageName, baseName)
	}

}
