package main

import (
	"fmt"
	"github.com/everfix/pkg/communication"
	"github.com/everfix/pkg/generator"
	"github.com/everfix/pkg/parser"
	"github.com/everfix/pkg/remediation"
	"log"
	"path/filepath"

	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/neo4j"
)

func main() {

	conf := new(config.Config)
	err := config.InitConfig(conf)
	if err != nil {
		fmt.Println("configuration initialization error")
		return
	}
	imageTree := new(remediation.ImageTreeNode)
	children := make(map[string][]string)
	// example on graph assembling
	neo4j.AssembleGraph(*conf, conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource,
		"Dockerfile", imageTree, children)

	// generate the vulnerability table
	generator.GenerateVulTable(conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource, config.TABLE)
	vulnerabilities := parser.GetVulnerability(filepath.Join("vul", conf.ImageConfig.ImageName+".txt"))

	// query for images connected with vulnerable packages
	for i, vul := range vulnerabilities {
		connectedImages, err := neo4j.GetConnectedImages(vul.PkgName)
		if err != nil {
			fmt.Println("Error fetching connected images", err)
		}
		vulnerabilities[i].ConnectedImages = connectedImages
	}
	// get remediation strategy and initialize data structure for rpc
	for i, vul := range vulnerabilities {
		remediationSteps, err := remediation.GetRemediationWorkflow(vul.ConnectedImages, imageTree)
		if err != nil {
			fmt.Println("Error getting the remediation image")
		}
		vulnerabilities[i].RemediationSteps = remediationSteps
		vulnerabilities[i].FixStatus = config.NewRWMap()

		fixImages := vulnerabilities[i].RemediationSteps[0].Images
		rebuildImages := vulnerabilities[i].RemediationSteps[1].Images
		for _, img := range fixImages {
			vulnerabilities[i].FixStatus.Set(img, "")
		}
		for _, img := range rebuildImages {
			vulnerabilities[i].FixStatus.Set(img, "")
		}
	}
	for _, vul := range vulnerabilities {
		err, finish := VulnerabilityRemediation(*conf, &vul, children)
		if !finish {
			fmt.Println("Failed to fix vulnerability", vul.Name)
		}
		if err != nil {
			fmt.Println("Error occurs when fixing the vulnerability", vul.Name)
		} else {
			fmt.Println("Successfully fixed the vulnerability", vul.Name)
		}
	}
	// todo: implement new concurrent algorithm for notifying different server to fix/rebuild images
	// steps:
	// 1. concurrently send rpc requests to servers to fix the related images for an vulnerability
	// 2. wait for all Acks and then, send rpc requests to servers to rebuild the second-last layer to rebuild some images
	// 3. wait for all Acks and then, send rpc requests to servers to rebuild the third-last layer
	// 4. repeat the above steps until all the related images have been rebuild

	// todo: the above steps do not need to strictly follow the order, they could be executed concurrently. If we have
	// time we could find ways to optimize it in the future.
}

func VulnerabilityRemediation(conf config.Config, vul *parser.Vulnerability, children map[string][]string) (error, bool) {
	// 1. fix the base images that related with the vulnerable packages
	err := communication.FixAllImages(conf, vul)
	if err != nil {
		log.Fatal("Image Fixed Error, exit")
		return err, false
	} else {
		fmt.Println("Finish the first phase(fix)")
	}

	// check if the first phase is successful
	fixImages := vul.RemediationSteps[0].Images
	fixStatus := vul.FixStatus
	for _, image := range fixImages {
		value, existed := fixStatus.Get(image)
		if !existed || value == "" {
			fmt.Println("First phase(fix) failed")
			return nil, false
		}
	}

	// 2. rebuild the images that their base images has already fixed
	err = communication.RebuildAllImages(conf, vul, children)
	if err != nil {
		log.Fatal("Image Rebuild Error, exit")
		return err, false
	} else {
		fmt.Println("Finish the second phase(rebuild)")
	}
	return nil, true
}
