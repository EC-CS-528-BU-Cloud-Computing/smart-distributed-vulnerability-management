package main

import (
	"fmt"
	"github.com/everfix/pkg/communication"
	"github.com/everfix/pkg/generator"
	"github.com/everfix/pkg/parser"
	"github.com/everfix/pkg/remediation"
	"log"
	"path/filepath"

	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/neo4j"
)

func main() {

	conf := new(config.Config)
	err := config.InitConfig(conf)
	if err != nil {
		fmt.Println("configuration initialization error")
		return
	}
	imageTree := new(remediation.ImageTreeNode)
	children := make(map[string][]string)
	parents := make(map[string][]string)
	// example on graph assembling
	neo4j.AssembleGraph(*conf, conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource,
		"Dockerfile", imageTree, children, parents)

	// generate the vulnerability table
	generator.GenerateVulTable(conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource, config.TABLE)
	vulnerabilities := parser.GetVulnerability(filepath.Join("vul", conf.ImageConfig.ImageName+".txt"))

	// query for images connected with vulnerable packages
	for i, vul := range vulnerabilities {
		connectedImages, err := neo4j.GetConnectedImages(vul.PkgName)
		if err != nil {
			fmt.Println("Error fetching connected images", err)
		}
		vulnerabilities[i].ConnectedImages = connectedImages
	}
	// get remediation strategy and initialize data structure for rpc
	for i, vul := range vulnerabilities {
		remediationSteps, err := remediation.GetRemediationWorkflow(vul.ConnectedImages, imageTree)
		if err != nil {
			fmt.Println("Error getting the remediation image")
		}
		vulnerabilities[i].RemediationSteps = remediationSteps
		vulnerabilities[i].FixStatus = config.NewRWMap()
		vulnerabilities[i].RebuildStatus = config.NewRWMap()

		fixImages := vulnerabilities[i].RemediationSteps[0].Images
		for _, img := range fixImages {
			vulnerabilities[i].FixStatus.Set(img, false)
		}
		rebuildImages := vulnerabilities[i].RemediationSteps[1].Images
		for _, img := range rebuildImages {
			vulnerabilities[i].RebuildStatus.Set(img, false)
		}
	}
	for _, vul := range vulnerabilities {
		err := VulnerabilityRemediation(*conf, vul)
		if err != nil {
			fmt.Println("Error occurs when fixing the vulnerability", vul.Name)
		} else {
			fmt.Println("Successfully fixed the vulnerability", vul.Name)
		}
	}
	// todo: implement new concurrent algorithm for notifying different server to fix/rebuild images
	// steps:
	// 1. concurrently send rpc requests to servers to fix the related images for an vulnerability
	// 2. wait for all Acks and then, send rpc requests to servers to rebuild the second-last layer to rebuild some images
	// 3. wait for all Acks and then, send rpc requests to servers to rebuild the third-last layer
	// 4. repeat the above steps until all the related images have been rebuild

	// todo: the above steps do not need to strictly follow the order, they could be executed concurrently. If we have
	// time we could find ways to optimize it in the future.
}

func VulnerabilityRemediation(conf config.Config, vul parser.Vulnerability) error {
	imagesToFix := vul.RemediationSteps[0].Images
	//imagesToRebuild := vul.RemediationSteps[1].Images
	fixedStatus := vul.FixStatus
	vulName := vul.Name
	err := communication.FixAllImages(conf, vulName, imagesToFix, fixedStatus)
	if err != nil {
		log.Fatal("Image Fixed Error, exit")
		return err
	}
	return nil
}
