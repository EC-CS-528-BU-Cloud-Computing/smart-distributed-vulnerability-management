package main

import (
	"fmt"
	"github.com/everfix/pkg/generator"
	"github.com/everfix/pkg/parser"
	"github.com/everfix/pkg/remediation"
	"path/filepath"

	"github.com/everfix/pkg/config"
	"github.com/everfix/pkg/neo4j"
)

func main() {

	conf := new(config.Config)
	err := config.InitConfig(conf)
	if err != nil {
		fmt.Println("configuration initialization error")
		return
	}
	imageTree := new(remediation.ImageTreeNode)
	children := make(map[string][]string)
	// example on graph assembling
	neo4j.AssembleGraph(*conf, conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource, "Dockerfile", imageTree, children)

	// generate the vulnerability table
	generator.GenerateVulTable(conf.ImageConfig.ImageName, conf.ImageConfig.ImageSource, config.TABLE)
	vulnerabilities := parser.GetVulnerability(filepath.Join("vul", conf.ImageConfig.ImageName+".txt"))

	// query for images connected with vulnerable packages
	for i, vul := range vulnerabilities {
		connectedImages, err := neo4j.GetConnectedImages(vul.PkgName)
		if err != nil {
			fmt.Println("Error fetching connected images", err)
		}
		vulnerabilities[i].ConnectedImages = connectedImages
	}
	// query to get the remediation image
	for i, vul := range vulnerabilities {
		remediationSteps, err := remediation.GetRemediationWorkflow(vul.ConnectedImages, imageTree)
		if err != nil {
			fmt.Println("Error getting the remediation image")
		}
		vulnerabilities[i].RemediationSteps = remediationSteps
	}

	// for testing the functionality
	for _, vul := range vulnerabilities {
		fmt.Println("vulnerability name:", vul.Name, " pkg name:", vul.PkgName)
		fmt.Println(vul.RemediationSteps)
	}
	fmt.Println("---------------")
	fmt.Println(children)

	// todo: implement new concurrent algorithm for notifying different server to fix/rebuild images
	// steps:
	// 1. concurrently send rpc requests to servers to fix the related images for an vulnerability
	// 2. wait for all Acks and then, send rpc requests to servers to rebuild the second-last layer to rebuild some images
	// 3. wait for all Acks and then, send rpc requests to servers to rebuild the third-last layer
	// 4. repeat the above steps until all the related images have been rebuild

	// todo: the above steps do not need to strictly follow the order, they could be executed concurrently. If we have
	// time we could find ways to optimize it in the future.
}
